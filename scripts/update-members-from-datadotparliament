#!/usr/bin/env python

# Grabs the latest members data from data.parliament XML and update accordingly.
# Get data using crawl-datadotparl-members.py

from lxml import etree
from datetime import datetime

# Source XML files to use for the list of members
source_files = [
  'all-current-commons'
]

parser = etree.ETCompatXMLParser()
etree.set_default_parser(parser)

# Create the master ministers element
ministers = etree.Element('publicwhip')


class TimePeriod(object):
  def __init__(self, el):
    self.el = el

  def make_date(self, s):
    return datetime.strptime(self.el.find(s).text, '%Y-%m-%dT00:00:00').strftime('%Y-%m-%d')

  @property
  def dates(self):
    start = self.make_date('StartDate')
    end = self.make_date('EndDate') if self.el.find('EndDate').text else '9999-12-31'
    return start, end


class Position(object):
  def __init__(self, position, positions):
    self.position = position
    self.list = positions

  @property
  def time_periods(self):
    position = self.position
    attrs = {}
    if self.list.name_is_dept:
      attrs['position'] = ''
    elif position.find('HansardName').text is not None:
      attrs['position'] = position.find('HansardName').text
    else:
      attrs['position'] = position.find('Name').text
    position_dates = TimePeriod(self.position).dates
    attrs['fromdate'], attrs['todate'] = position_dates
    periods = [ attrs ]
    chairdates = position.find('ChairDates')
    if chairdates is None or not len(chairdates):
      return periods
    if len(chairdates) > 1:
      raise Exception("Doesn't currently handle more than one chair date, one was bad enough!")
    chair_dates = TimePeriod(chairdates.find('ChairDate')).dates
    if chair_dates[0] <= position_dates[0]:
      attrs['position'] = 'Chair'
      if chair_dates[1] < position_dates[1]:
        attrs['todate'] = chair_dates[1]
        periods.append({'position': '', 'fromdate': chair_dates[1], 'todate': position_dates[1]})
    else:
      attrs['todate'] = chair_dates[0]
      if chair_dates[1] < position_dates[1]:
        periods.append({'position': 'Chair', 'fromdate': chair_dates[0], 'todate': chair_dates[1]})
        periods.append({'position': '', 'fromdate': chair_dates[1], 'todate': position_dates[1]})
      else:
        periods.append({'position': 'Chair', 'fromdate': chair_dates[0], 'todate': position_dates[1]})
    return periods

  def generate(self):
    position = self.position
    for period in self.time_periods:
      el = etree.SubElement(ministers, 'moffice')
      attrs = el.attrib
      attrs['id'] = 'uk.parliament.data/Member/%s/%s/%s%s' % (
        self.list.member.attrib['datadotparl_id'], self.list.typ, position.attrib['Id'], self.counter)
      attrs['type'] = self.list.typ.lower()
      attrs['source'] = 'datadotparl/%s' % self.list.typ.lower()
      attrs['position'] = period['position']
      attrs['name'] = self.list.member.attrib['firstname'] + ' ' + self.list.member.attrib['lastname']
      attrs['matchid'] = self.list.member.attrib['id']
      attrs['dept'] = position.find('Name').text if self.list.name_is_dept else ''
      attrs['fromdate'] = period['fromdate']
      attrs['todate'] = period['todate']

  @property
  def counter(self):
    extra = ''
    id = self.position.attrib['Id']
    if self.list.counter.setdefault(id, 0):
      extra = '/%d' % self.list.counter[id]
    self.list.counter[id] += 1
    return extra


class Positions(object):
  def __init__(self, data, member):
    self.data = data
    self.member = member

  def filter(self, typ, name_is_dept=False):
    container = typ + 's'
    if self.data.find(container) is None:
      return
    self.counter = {}
    self.typ = typ
    self.name_is_dept = name_is_dept
    for p in self.data.find(container).findall(typ):
      pos = Position(p, self)
      yield pos


def parse(fn, root_tag):
  try:
    xml = etree.parse(fn).getroot()
  except:
    raise Exception('Data from %s does not seem to be valid XML.' % fn)
  if xml.tag != root_tag:
    raise Exception('Root tag in %s is not "%s" as expected, got "%s"' % (fn, root_tag, xml.tag))
  return xml


for source_file in source_files:
  parl_members_slim = parse('../rawdata/datadotparl/' + source_file + '.xml', 'Members')
  print 'Found ' + str(len(parl_members_slim)) + ' members from ' + source_file + '.xml.'

  # Enrich the data!
  parl_members = dict()
  for member in parl_members_slim:
    member_fullbio_xml = parse('../rawdata/datadotparl/' + member.attrib['Member_Id'] + '.xml', 'Members')
    parl_members[member.attrib['Member_Id']] = member_fullbio_xml.find('Member')

  ##########
  # At this point parl_members contains a complete set of data.
  ##########

  # Import people.xml
  people_xml = parse('../members/people.xml', 'publicwhip')
  people = {}
  for person in people_xml:
    pid = person.attrib['id']
    for office in person:
      oid = office.attrib['id']
      people[oid] = pid

  # Import the current all-members.xml
  current_members = parse('../members/all-members-2010.xml', 'publicwhip')
  print 'Found ' + str(len(current_members)) + ' members from all-members-2010.xml.'

  # From the current members, find those who aren't currently explicitly matched.
  unmatched_members = dict()
  for member in current_members:
    if 'datadotparl_id' not in member.attrib:
      member_name = member.attrib['lastname'] + ', ' + member.attrib['firstname']
      unmatched_members.setdefault(member_name, []).append(member)

  # Compare parl_members to unmatched_members
  for member_id, parl_member in parl_members.items():
    if parl_member.find('ListAs').text in unmatched_members:
      for unmatched_member in unmatched_members[parl_member.find('ListAs').text]:
        ## TODO: Prompt to check if this match is actually correct
        unmatched_member.attrib['datadotparl_id'] = parl_member.attrib['Member_Id']

  # Find current members with datadotparl_id
  matched_members = [ m for m in current_members if 'datadotparl_id' in m.attrib ]
  print str(len(matched_members)) + ' members with data.parliament ID.'

  # Pick out the member from parliamentary data with the right ID
  already_seen = set()
  for matched_member in matched_members:
    if people[matched_member.attrib['id']] in already_seen:
      continue
    already_seen.add(people[matched_member.attrib['id']])

    parl_data = parl_members[matched_member.attrib['datadotparl_id']]
    positions = Positions(parl_data, matched_member)

    for position in positions.filter('GovernmentPost'):
      position.generate()
    for position in positions.filter('OppositionPost'):
      position.generate()
    for position in positions.filter('ParliamentaryPost'):
      position.generate()
    for position in positions.filter('Committee', name_is_dept=True):
      position.generate()

  print 'Done for ' + source_file + '.xml.'

# Write out the updated ministers file
ministers_xml = etree.ElementTree(ministers)
ministers_xml.write('../members/ministers-2010.xml', pretty_print=True)
print 'ministers-2010.xml updated!'

print 'Done!'
